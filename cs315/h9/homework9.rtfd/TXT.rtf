{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf190
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fswiss\fcharset0 Helvetica;\f2\fmodern\fcharset0 Courier;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue233;\red0\green116\blue0;\red100\green56\blue32;
\red196\green26\blue22;\red170\green13\blue145;\red28\green0\blue207;}
\margl1440\margr1440\vieww21840\viewh13700\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc

\f0\fs30 \cf0 											Homework9
\fs22 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 1. We saw in class that the text's {\field{\*\fldinst{HYPERLINK "http://cs.usfca.edu/~peter/cs315/code/arith/text_bin_div.pdf"}}{\fldrslt \cf2 \ul \ulc2 original algorithm for division}} can determine when there's been division by 0, since the quotient will overflow. Apply the {\field{\*\fldinst{HYPERLINK "http://cs.usfca.edu/~peter/cs315/code/arith/div2-alg.pdf"}}{\fldrslt \cf2 \ul \ulc2 improved algorithm for division}} to the 2-bit binary division 01/11. Show the contents of each of the registers at the start of execution and after each step of the algorithm. Does the improved algorithm detect overflow? If so, how does it detect this?\
\
\

\f1\fs24 {{\NeXTGraphic Screen Shot 2014-04-11 at 1.53.39 PM.png \width11960 \height7980
}¬}
\f0\fs22 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \
\pard\pardeftab720
\cf0 The improved algorithm cannot detect overflow.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \
\
\
2. Using a table similar to that shown in Figure 3.10, calculate 74 divided by 21 using the hardware described in Figure 3.8. You should show the contents of each register on each step. Assume both inputs are unsigned 6-bit integers.\
\
74(octal) = 111100(bin)\'97\'97\'97\'97>Dividend\
21(octal) = 010001(bin)\'97\'97\'97\'97>Divisor\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f1\fs24 \cf0 {{\NeXTGraphic Screen Shot 2014-04-09 at 10.27.11 PM.png \width10700 \height11940
}¬}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f0\fs22 \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \
So 74(octal)/21(octal), \
quotient = 11(bin)= 3(octal)\
Remainder = 1001(bin) = 11(octal)\
\
3. Write a C program that determines whether the C-compiler on the lab machines generates code that uses the "Mathematicians'" method or "Some Computer Scientists'" method for finding quotients and remainders. Include in your documentation which method is used.\
\
\pard\tx529\pardeftab529\pardirnatural
\cf3 \CocoaLigature0 /* File: 3.c\
 * Purpose: determines whether the C-compiler on the lab machines generates code \
 *			that uses the "Mathematicians'" method or "Some Computer Scientists'" method.\
 * Compile: gcc -g -Wall -o 3 3.c\
 * Run:		./3 \
 * Input: None\
 * Output: whether "It's Some Computer Scientists'" or "It's Mathematicians'"\
 */\cf0 \
\
\
\cf4 #include \cf5 <stdlib.h>\cf4 \
#include \cf5 <stdio.h>\cf4 \
\cf0 \
\cf6 const\cf0  \cf6 int\cf0  MAX = \cf7 50\cf0 ;\
\
\cf6 int\cf0  main( ) \{\
    \cf6 int\cf0  x = -\cf7 7\cf0 ;\
    \cf6 int\cf0  y = \cf7 2\cf0 ;\
    \cf6 int\cf0  rem = x / y;\
    \
    \cf6 char\cf0  array1[\cf7 50\cf0 ] = \cf5 "It's Some Computer Scientists'"\cf0 ;\
    \cf6 char\cf0  array2[\cf7 50\cf0 ] = \cf5 "It's Mathematicians'"\cf0 ;\
    \
    \cf6 if\cf0  (rem < \cf7 0\cf0 )\
        printf(\cf5 "%s\\n"\cf0 , array1);\
    \cf6 else\cf0 \
        printf(\cf5 "%s\\n"\cf0 , array2);\
    \
    \cf6 return\cf0  \cf7 0\cf0 ;\
\}\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \CocoaLigature1 \
4.1 Consider the following instruction:\
Instruction: AND Rd,Rs,Rt\
Interpretation: Reg[Rd] = Reg[Rs] AND Reg[Rt]\'94\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f1\fs24 \cf0 {{\NeXTGraphic Screen Shot 2014-04-10 at 12.28.52 PM.png \width12580 \height9480
}¬}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f0\fs22 \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 (1) What are the values of control signals generated by the control in Figure 4.2 for the following instruction?\'94\
     AND is an ALU Operation, so:\
      a. RegWrite: true\
      b. BottomMux: register\
      c. MidMux: ALU\
      d. ALUoperation: AND\
      e. MemRead: false\
      f. MemWrite: false\
      g. Branch: false\
\
(2) Which resources (blocks) perform a useful function for this instruction?\
     \
	 There are PC, Instruction memory, Registers, ALU, Bottom MUX, Middle MUX, Top MUX\
\
(3) Which resources (blocks) produce outputs, but their outputs are not used for this instruction? Which resources produce no outputs for this instruction?\
      \
	There are branch, Data memory\
\
4.2  The basic single-cycle MIPS implementation in Figure 4.2 can only implement some instructions. New instructions can be added to an existing Instruction Set Architecture (ISA), but the decision whether or not to do that depends, among other things, on the cost and complexity the proposed addition introduces into the processor datapath and control. The first three problems in this exercise refer to the new instruction:\
Instruction: LWI Rt,Rd(Rs)\
Interpretation: Reg[Rt] = Mem[Reg[Rd]+Reg[Rs]]\
\
(1) Which existing blocks (if any) can be used for this instruction?\
	\
	There are PC, Registers, Bottom MUX, ALU, Data memory,Top MUX, Middle MUX.\
\
(2) Which new functional blocks (if any) do we need for this instruction?\
	\
	There\'92s no new functional blocks.\
\
(3) What new signals do we need (if any) from the control unit to support this instruction?\
	\
	There\'92s no new signals\
\
\
\
\
\
\
Answer:\
1.\
\pard\pardeftab720

\f2\fs26 \cf0 Note that in order to implement subtraction using two's complement \
addition and represent negative values, we need to add an extra bit \
to Divisor and Rem when we do the subtraction.\
\
Start:  Divisor   Rem Quot   -Divisor\
           11      00 01      101\
                   00 10\
           \
Step 0: Rem -= Divisor = 101 < 0\
\
        Divisor   Rem Quot\
           11      01 00\
\
Step 1: Rem -= Divisor = 110 < 0\
\
        Divisor   Rem Quot\
           11      10 00\
\
Output: Quot = 0, Rem = 1\
\
\
To check for problems with division by 0, we can look at 1/0\
\
Start:  Divisor   Rem Quot   -Divisor\
           00      00 01       00\
                   00 10\
           \
Step 0: Rem -= Divisor = 00 >= 0\
\
        Divisor   Rem Quot\
           00      01 01\
\
Step 1: Rem -= Divisor = 01 >= 0 \
\
        Divisor   Rem Quot\
           00      10 11\
\
Output: Quot = 11, Rem = 01\
\
In general, if we use this algorithm to divide an unsigned value\
by 0, the quotient will be -1 (all bits are 1), and the remainder \
will be equal to the dividend.}